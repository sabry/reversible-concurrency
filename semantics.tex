\documentclass{article}
\usepackage{fullpage}
\usepackage{stmaryrd}
\usepackage{latexsym}

\title{Distributed Backtracking}
\author{}
\date{}
\begin{document}
\maketitle

\newcommand{\alt}{~|~}
\newcommand{\parc}[2]{#1 \,\|\, #2}
\newcommand{\send}[2]{\texttt{send}~#1~#2}
\newcommand{\stable}[1]{\texttt{stable}~#1}
\newcommand{\stableu}[1]{\underline{\texttt{stable}}~#1}
\newcommand{\backtrack}[1]{\texttt{backtrack}~#1}
\newcommand{\recv}[4]{\texttt{recv}~(#1.#2) \talloblong (#3.#4)}
\newcommand{\proc}[5]{\langle #1@#5:~ #3, #2,#4 \rangle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax} 

\paragraph*{Ids.} Each process has an id $n$ and each channel has an id
$\ell$.

\paragraph*{Time.} Each process maintains a \emph{virtual time} which is an
indication of how far it has progressed in the evaluation. If process $n$ is
at virtual time $t$, this is indicated by $n@t$. The virtual times of
processes evolve independently and may be inconsistent globally. However
whenever a communication event happens, the virtual times of the sender and
receiver processes are synchronized and brought to a consistent state.

\paragraph*{Channels.} Processes communicate via named channels. Each channel
$\ell$ is associated with exactly two processes: a sender and a receiver.
Each of the sender and receiver maintains a \emph{local view} of the
channel's state as follows. The sender maintains a virtual time associated
with its latest request to communicate on the channel and a flag indicating
whether it the channel is in the normal (forward) state (flag is $F$) or
whether the communication on the channel needs to be undone because of
backtracking (flag is $B$). The receiver maintains two similar variables: a
virtual time indicating the latest acknowledgment it communicated on the
channel and a flag (whose value is also $F$ or $B$) indicating whether the
receiver views that the channel in the normal forward state or the
backtracking state. The views of the sender and receiver may be inconsistent
at times but are synchronized at communication times. The main invariant is
that when both views of the channel indicate the channel state to be $F$,
then the two virtual times associated with the sender and receiver views
coincide. The channel information is maintained in a \emph{local} map $\Xi$
associated with each process.

\paragraph*{Communication Model.} We focus on \emph{synchronous}
channel-based communication. The model supports \emph{choice}: the expression
$\recv{x_1}{\ell_1}{x_2}{\ell_2}$ can receive a message on either channel
$\ell_1$ or $\ell_2$. If both choices are offered, the evaluation of the
expression is permitted to choose which one to accept. 

\paragraph*{Processes.} A process computes forward and backwards sending and
receiving messages. To enable distributed backtracking, each process maintain
a virtual time $t$, a channel map $\Xi$, and a stack $\Gamma$ of
contexts. Each context includes a conventional continuation (a control point
and an environment), a time stamp, and a channel map describing the state of
the communication channels at the time of the checkpoint. 

\paragraph*{Grammar.}

\[\begin{array}{lrcl}
(\textit{process names}) & n, \ldots \\
(\textit{channel names}) & \ell, \ldots \\
(\textit{time stamps}) & t, \ldots \\
\\
(\textit{channel direction}) & d &::=& F \alt B \\
(\textit{channel port}) & sr &::=& \textbf{s} \alt \textbf{r} \\
(\textit{channel maps}) & \Xi &=& \ell \mapsto (sr,t,d,n) \\
(\textit{context stacks}) & \Gamma &=& \bullet \alt \Gamma,(E,t,\Xi) \\
\\
(\textit{processes}) & p &::=& (\parc{p_1}{p_2}) \alt \proc{n}{\Gamma}{\Xi}{e}{t} \\
\\
(\textit{values}) & v &::=& () \alt \ell \alt x \alt \lambda x.e \\
(\textit{expressions}) & e &::=& () \alt \ell \alt x \alt \lambda x.e 
  \alt e_1e_2 \\
  &&\alt& \send{e_1}{e_2} \alt \recv{x_1}{e_1}{x_2}{e_2} \\
  &&\alt& \stable{e} \alt \stableu{e} \alt \backtrack{e} \\
\\
(\textit{evaluation contexts}) & E &::=& \Box \alt E~e \alt v~E \alt 
  \send{E}{e} \alt \send{\ell}{E} \\
  &&\alt& \recv{x_1}{E}{x_2}{e_2} \alt \recv{x_1}{\ell_1}{x_2}{E} \\
  &&\alt& \stable{E} \alt \stableu{E} \alt \backtrack{E}
\end{array}\]

We use $e_1;e_2$ as syntactic sugar for $(\lambda \_.e_2)~e_1$ to indicate
sequencing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Semantics} 

Initially, every process starts with virtual time 0, a channel map
associating each channel that this process can use as a sender or receiver to
$(0,F,n)$ where $n$ is the process at the other end of the channel, an empty
stack of contexts, and an expression to evaluate, i.e., process $n_i$ with
code $e_i$ starts in the configuration
$\proc{n_i}{\bullet}{\Xi_i}{\Box[e_i]}{0}$ where $\Xi_1$ is the initial
channel map as explained above. The rules for evolving the collection of
processes are as follows:

\begin{itemize}
\item The first rule just applies a local evaluation rule to one of the
  running processes. The remaining processes, the local timestamp, the local
  channel map, and the local stack of contexts are all left untouched. (We
  only increase the timestamp for ``relevant'' rules which involve
  communication.)
\[\begin{array}{rcl}
  \parc{p}{\proc{n}{\Gamma}{\Xi}{E[(\lambda x.e)~v]}{t}} &\mapsto& 
  \parc{p}{\proc{n}{\Gamma}{\Xi}{E[e[v/x]]}{t}}
\end{array}\]

\item This next rule deals with the normal forward communication between two
  processes. 

says that if we have a channel $\ell$ with flag $F$ and two
  processes who wish to communicate using this channel, the synchronization
  happens as usual. After the communication, all three timestamps are updated
  to some number that is greater than or equal to their maximum:
\[\begin{array}{l}
  \parc{p}
  {\parc{\proc{n_1}{\Gamma_1}{\Xi_1}{E_1[\send{\ell}{v}]}{t_1}}
        {\proc{n_2}{\Gamma_2}{\Xi_2}{E_2[\recv{x}{\ell}{x'}{\ell'}]}{t_2}}}
  \mapsto \\
  \parc{p}{\parc{\proc{n_1}{\Gamma_1}{\Xi_1'}{E_1[()]}{t}}
    {\proc{n_2}{\Gamma_2}{\Xi_2'}{E_2[v]}{t}}}
\end{array}\]
The preconditions for this rule are: 
\begin{itemize}
\item the sender's local channel map associates $\ell$ with
  $(\textbf{s},t_s,F,n_2)$, i.e., the map correctly identifies $n_2$ as the
  receiving process, and records that the channel direction is $F$, and has
  some virtual time $t_s$;
\item the receiver's local channel map associates $\ell$ with
  $(\textbf{r},t_r,F,n_1)$, i.e., the map correctly identifies $n_1$ as the
  sending process, and records that the channel direction is $F$, and has
  some virtual time $t_r$; and
\item the sender's virtual time is greater than the channel's virtual time in
  the sender's map, i.e., $t_1 > t_s$, and similarly for the receiver's
  virtual time, i.e., $t_2 > t_r$.
\end{itemize}
If these conditions are satisfied, the communication happens, and the virtual
times for the sender, receiver, and the channel times in each local map are
all updated to some time $t$ greater than the maximum of
$\{t_1,t_2,t_s,t_r\}$. In other words, the sender's resulting local map
$\Xi_1'$ associates $\ell$ with $(\textbf{s},t,F,n_2)$, and the receiver's
resulting local map $\Xi_2'$ associates $\ell$ with
$(\textbf{r},t,F,n_1)$. In the rule, the receiver non-deterministically
``chose'' to communicate on channel $\ell$. If another process $n_1'$ was
ready to communicate on channel $\ell'$ (and the preconditions were satisfied
for that communication), the receiver could have synchronized wit $n_1'$
using the same rule.

\item The next two rules deal with stable regions. When a new stable region
  is encountered, the evaluation increments the timestamp and saves a new
  context, which is restored should the evaluation backtrack within the
  dynamic extent of the stable region:
\[\begin{array}{rcl}
  \parc{p}{\proc{n}{\Gamma}{\Xi}{E[(\stable{(\lambda x.e)})~v]}{t}} &\mapsto&
  \parc{p}{\proc{n}{\Gamma'}{\Xi}{E[\stableu{e[v/x]}]}{(t+1)}} 
\end{array}\]
where $\Gamma' = \Gamma,(E,(t+1),\Xi)$. When the body of a stable 
region terminates with a value, we simply pop the context:
\[\begin{array}{rcl}
  \parc{p}{\proc{n}{(\Gamma,(E,t',\Xi'))}{\Xi}{E[\stableu{v}]}{t}} 
  &\mapsto& 
  \parc{p}{\proc{n}{\Gamma}{\Xi}{E[v]}{t}} 
\end{array}\]

\item So far, none of the rules caused any virtual time to decrease. When a
  process $n$ backtracks, however, its virtual time is reinstated to a
  previously saved time. In addition, we recover the saved state of the
  channels and update each channel to have a flag $B$ to indicate the start
  of a backtracking process for communication events on that channel.  We
  then resume execution with the saved continuation:
\[\begin{array}{rcl}
  \parc{p}{\proc{n}{(\Gamma,(E',t',\Xi'))}{\Xi}{E[\backtrack{v}]}{t}} 
  &\mapsto& 
  \parc{p}{\proc{n}{\Gamma}{\overline{\Xi'}}{E'[v]}{t'}} 
\end{array}\]
where $\overline{\Xi'}$ denotes the channel map $\Xi$ with each entry updated
to have direction $B$.

\item The next set of rules deal with the situation in which one of the
  processes has backtracked but its communication partner has not. In more
  detail, when the common channel has flag $B$, it is either the case that
  someone has to backtrack further or that the two involved processes have
  backtracked enough and the channel's flag can be updated to $F$. In this
  first rule, the sender needs to backtrack:
\[\begin{array}{l}
  \Xi,
  \parc{p}{\proc{n_1}{\Gamma}{\Xi}{E[\send{\ell}{v}]}{t_1}} \mapsto \\
  \Xi,
  \parc{p}{\proc{n_1}{\Gamma}{\Xi}{E[\backtrack{()}; \send{\ell}{v}]}{t_1}}
\end{array}\]
if $(\ell,(t_c,B,n_1,n_2)) \in \Xi_1$ and $t_c < t_1$. This condition
indicates that $n_2$ has backtracked to a time consistent with $t_c$ and
hence that $n_1$ is still in the (inconsistent) future and hence should do
the same. We achieve this by executing $\backtrack{()}$ which moves to the
most recent saved context and attempts to re-execute the communication.  If
that fails, this same rule applies and we backtrack again.  There is a
symmetric rule for receivers.

Eventually, the process backtracks to a time $t_1$ such that $t_c \geq t_1$,
at which we can revert the channel to the flag $F$:
\[\begin{array}{l}
  \Xi_1,
  \parc{p}{\proc{n_1}{\Gamma}{\Xi}{E[\send{\ell}{v}]}{t_1}} \mapsto \\
  \Xi_2,
  \parc{p}{\proc{n_1}{\Gamma}{\Xi}{E[\send{\ell}{v}]}{t_1}} 
\end{array}\]
if $(\ell,(t_c,B,n_1,n_2)) \in \Xi_1$ and $t_c \geq t_1$ and channel $\ell$'s
information in $\Xi_2$ is updated to $t_c,F,n_1,n_2)$.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
