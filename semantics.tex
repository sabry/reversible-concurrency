\documentclass{article}
\usepackage{fullpage}
\usepackage{stmaryrd}
\usepackage{latexsym}

\title{Distributed Backtracking}
\author{}
\date{}
\begin{document}
\maketitle

\newcommand{\alt}{~|~}
\newcommand{\parc}[2]{#1 \,\|\, #2}
\newcommand{\send}[2]{\texttt{send}~#1~#2}
\newcommand{\stable}[1]{\texttt{stable}~#1}
\newcommand{\stableu}[1]{\underline{\texttt{stable}}~#1}
\newcommand{\backtrack}[1]{\texttt{backtrack}~#1}
\newcommand{\recv}[4]{\texttt{recv}~(#1.#2) \talloblong (#3.#4)}
\newcommand{\proc}[4]{\langle #1@#4:~ #2,#3 \rangle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax} 

\paragraph*{Ids.} Each process has an id $n$ and each channel has an id
$\ell$.

\paragraph*{Time.} Each process and each channel maintain a \emph{virtual
  time} which is an indication of how far they have progressed in the
evaluation. If process $n$ is at virtual time $t$, this is indicated by
$n@t$. The virtual times evolve independently and may be inconsistent
globally. However whenever a communication event happens, the virtual times
of all involved parties (the sender process, the receiver process, and the
communication channel) are all synchronized and brought to a consistent
state.

\paragraph*{Channels.} Processes communicate via named channels. Each channel
$\ell$ is associated with exactly two processes: a sender $s(\ell)$ and a
receiver $r(\ell)$. A channel maintains a flag indicating whether both
attached processes are going forward (flag is $F$) or if at least one of them
is backtracking (flag is $B$). A channel also maintains a virtual time which
roughly corresponds to the time of the latest ``real'' communication on that
channel, i.e., communication occurring with neither party backtrackig. It
should never be the case that a channel with flag $F$ has a time ahead of its
associated processes because the times are synchronized at each communication
and the associated processes can only increase their local times after the
communication. A process~$n@t$ can only send or receive on a channel whose
channel flag is $F$, which implies that the channel's virtual time $t_c$ is
such that $t_1 \geq t_c$. If process~$n@t$ wants to communicate on a channel
whose flag is $B$, this means that the partner process at the other end is
backtracking and hence that process $n$ should also backtrack to at least
some time $\leq t_c$. The current timestamps on channels are maintained in a
\emph{global} map $\Xi$. A process who id is $n$ can however only ``see'' the
part of the map that refers to its channels: we refer to this part as
$\Xi\downarrow n$.

\paragraph*{Communication Model.} We focus on \emph{synchronous}
channel-based communication. The model supports \emph{choice}: the expression
$\recv{x_1}{\ell_1}{x_2}{\ell_2}$ can receive a message on either channel
$\ell_1$ or $\ell_2$. If both choices are offered, the evaluation of the
expression is permitted to choose which one to accept. 

\paragraph*{Processes.} A process computes forward and backwards sending and
receiving messages. To enable distributed backtracking, each process maintain
a virtual time $t$ and a stack $\Gamma$ of contexts. Each context includes a
conventional continuation (a control point and an environment), a time stamp,
and a channel map describing the state of the communication channels at the
time of the checkpoint. (Only the portion of the channel map specific to the
process needs to be saved but we save the entire channel map for simplicity.)

\paragraph*{Grammar.}

\[\begin{array}{lrcl}
(\textit{process names}) & n, \ldots \\
(\textit{channel names}) & \ell, \ldots \\
(\textit{time stamps}) & t, \ldots \\
\\
(\textit{channel direction}) & d &::=& F \alt B \\
(\textit{channel maps}) & \Xi &=& \ell \mapsto (t,d,n_1,n_2) \\
(\textit{context stacks}) & \Gamma &=& \bullet \alt \Gamma,(E,t,\Xi) \\
\\
(\textit{processes}) & p &::=& (\parc{p_1}{p_2}) \alt \proc{n}{\Gamma}{e}{t} \\
\\
(\textit{values}) & v &::=& () \alt \ell \alt x \alt \lambda x.e \\
(\textit{expressions}) & e &::=& () \alt \ell \alt x \alt \lambda x.e 
  \alt e_1e_2 \\
  &&\alt& \send{e_1}{e_2} \alt \recv{x_1}{e_1}{x_2}{e_2} \\
  &&\alt& \stable{e} \alt \stableu{e} \alt \backtrack{e} \\
\\
(\textit{evaluation contexts}) & E &::=& \Box \alt E~e \alt v~E \alt 
  \send{E}{e} \alt \send{\ell}{E} \\
  &&\alt& \recv{x_1}{E}{x_2}{e_2} \alt \recv{x_1}{\ell_1}{x_2}{E} \\
  &&\alt& \stable{E} \alt \stableu{E} \alt \backtrack{E}
\end{array}\]

We use $e_1;e_2$ as syntactic sugar for $(\lambda \_.e_2)~e_1$ to indicate
sequencing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Semantics} 

Initially, every process starts with virtual time 0, an empty stack of
contexts, and an expression to evaluate, i.e., process $n_i$ with code $e_i$
starts in the configuration $\proc{n_i}{\bullet}{\Box[e_i]}{0}$. The rules
for evolving the collection of processes are as follows:

\begin{itemize}
\item The first rule just applies a local evaluation rule to one of the
  running processes. The remaining processes, the global channel map, the
  local timestamp, and the local stack of contexts are all left
  untouched. (We only increase the timestamp for ``relevant'' rules which
  involve communication.)
\[\begin{array}{rcl}
  \Xi,\parc{p}{\proc{n}{\Gamma}{E[(\lambda x.e)~v]}{t}} &\mapsto& 
  \Xi,\parc{p}{\proc{n}{\Gamma}{E[e[v/x]]}{t}}
\end{array}\]

\item This next rule says that if we have a channel $\ell$ with flag $F$ and
  two processes who wish to communicate using this channel, the
  synchronization happens as usual. After the communication, all three
  timestamps are updated to some number that is greater than or equal to
  their maximum:
\[\begin{array}{l}
  \Xi_1,\parc{p}
  {\parc{\proc{n_1}{\Gamma_1}{E_1[\send{\ell}{v}]}{t_1}}
        {\proc{n_2}{\Gamma_2}{E_2[\recv{x}{\ell}{x'}{\ell'}]}{t_2}}}
  \mapsto \\
  \Xi_2,\parc{p}{\parc{\proc{n_1}{\Gamma_1}{E_1[()]}{t}}
    {\proc{n_2}{\Gamma_2}{E_2[v]}{t}}}
\end{array}\]
if $(\ell,(t_{c},F,n_1,n_2)) \in \Xi_1$, the original channel map.  The entry
for $\ell$ in the resulting channel map $\Xi_2$ is $(t,F,n_1,n_2)$ for some
$t \geq t_1, t_2, t_c$. In the rule, the receiver non-deterministically
``chose'' to communicate on channel $\ell$. If another process $n_1'$ was
ready to communicate on channel $\ell'$ (and channel's $\ell'$ flag was $F$),
the receiver could have synchronized wit $n_1'$ using the same rule.

\item The next two rules deal with stable regions. When a new stable region
  is encountered, the evaluation increments the timestamp and saves a new
  context, which is restored should the evaluation backtrack within the
  dynamic extent of the stable region:
\[\begin{array}{rcl}
  \Xi,\parc{p}{\proc{n}{\Gamma}{E[(\stable{(\lambda x.e)})~v]}{t}} &\mapsto&
  \Xi,\parc{p}{\proc{n}{\Gamma'}{E[\stableu{e[v/x]}]}{(t+1)}} 
\end{array}\]
where $\Gamma' = \Gamma,(E,(t+1),\Xi)$. When the body of a stable 
region terminates with a value, we simply pop the context:
\[\begin{array}{rcl}
  \Xi,\parc{p}{\proc{n}{\Gamma,(E,t',\Xi')}{E[\stableu{v}]}{t}} 
  &\mapsto& 
  \Xi,\parc{p}{\proc{n}{\Gamma}{E[v]}{t}} 
\end{array}\]

\item So far, none of the rules caused any virtual time to decrease. When a
  process $n$ backtracks, however, its virtual time is reinstated to a
  previously saved time. In addition, we recover the saved state of the
  channels and update each channel involving $n$ to have a flag $B$ to
  indicate that one of its communicating partners is backtracking. We then
  resume execution with the saved continuation:
\[\begin{array}{rcl}
  \Xi,\parc{p}{\proc{n}{\Gamma,(E',t',\Xi')}{E[\backtrack{v}]}{t}} 
  &\mapsto& 
  (\Xi\uplus(\Xi'\downarrow n)^\dagger),\parc{p}{\proc{n}{\Gamma}{E'[v]}{t'}} 
\end{array}\]
In this rule, it is important to realize that process $n$ only updates the
part of the global map $\Xi$ that involves $n$. Otherwise, the progress by
other unrelated channels would be lost. The $\dagger$ operation updates the
flag associated with each of the channels involving $n$, i.e., each of the
channels in $\Xi' \downarrow n$ to $B$.

\item The next set of rules deal with the situation in which one of the
  processes has backtracked but its communication partner has not. In more
  detail, when the common channel has flag $B$, it is either the case that
  someone has to backtrack further or that the two involved processes have
  backtracked enough and the channel's flag can be updated to $F$. In this
  first rule, the sender needs to backtrack:
\[\begin{array}{l}
  \Xi,
  \parc{p}{\proc{n_1}{\Gamma}{E[\send{\ell}{v}]}{t_1}} \mapsto \\
  \Xi,
  \parc{p}{\proc{n_1}{\Gamma}{E[\backtrack{()}; \send{\ell}{v}]}{t_1}}
\end{array}\]
if $(\ell,(t_c,B,n_1,n_2)) \in \Xi_1$ and $t_c < t_1$. This condition
indicates that $n_2$ has backtracked to a time consistent with $t_c$ and
hence that $n_1$ is still in the (inconsistent) future and hence should do
the same. We achieve this by executing $\backtrack{()}$ which moves to the
most recent saved context and attempts to re-execute the communication.  If
that fails, this same rule applies and we backtrack again.  There is a
symmetric rule for receivers.

Eventually, the process backtracks to a time $t_1$ such that $t_c \geq t_1$,
at which we can revert the channel to the flag $F$:
\[\begin{array}{l}
  \Xi_1,
  \parc{p}{\proc{n_1}{\Gamma}{E[\send{\ell}{v}]}{t_1}} \mapsto \\
  \Xi_2,
  \parc{p}{\proc{n_1}{\Gamma}{E[\send{\ell}{v}]}{t_1}} 
\end{array}\]
if $(\ell,(t_c,B,n_1,n_2)) \in \Xi_1$ and $t_c \geq t_1$ and channel $\ell$'s
information in $\Xi_2$ is updated to $t_c,F,n_1,n_2)$.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
