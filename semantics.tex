\documentclass{article}
\usepackage{fullpage}
\usepackage{stmaryrd}
\usepackage{latexsym}

\title{Distributed Backtracking}
\author{}
\date{}
\begin{document}
\maketitle

\newcommand{\todo}[1]{\fbox{#1}}

\newcommand{\alt}{~|~}
\newcommand{\parc}[2]{#1 \,\|\, #2}
\newcommand{\send}[2]{\texttt{send}~#1~#2}
\newcommand{\stable}[1]{\texttt{stable}~#1}
\newcommand{\stableu}[1]{\underline{\texttt{stable}}~#1}
\newcommand{\backtrack}[1]{\texttt{backtrack}~#1}
\newcommand{\abacktrack}{\texttt{backtrack}\_}
\newcommand{\recv}[4]{\texttt{recv}~(#1.#2) \talloblong (#3.#4)}
\newcommand{\proc}[5]{\langle #1@#5:~ #3, #2,#4 \rangle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax} 

\paragraph*{Ids.} Each process has an id $n$ and each channel has an id
$\ell$.

\paragraph*{Time.} Each process maintains a \emph{virtual time} which is an
indication of how far it has progressed in the evaluation. If process $n$ is
at virtual time $t$, this is indicated by $n@t$. The virtual times of
processes evolve independently and may be inconsistent globally. However
whenever a communication event happens, the virtual times of the sender and
receiver processes are synchronized and brought to a consistent state.

\paragraph*{Channels.} Processes communicate via named channels. Each channel
$\ell$ is associated with exactly two processes: a sender and a receiver.
Each of the sender and receiver maintains a \emph{local view} of the
channel's state as follows. The sender maintains a virtual time associated
with its latest request to communicate on the channel and a flag indicating
whether it views the channel as being in the normal (forward) state (flag is
$F$) or in a backtracking state (flag is $B$). The receiver maintains two
similar variables: a virtual time indicating the latest acknowledgment it
communicated on the channel and a flag (whose value is also $F$ or $B$).  The
views of the sender and receiver may be inconsistent at times but are
synchronized at communication times. The main invariant is that when both
views of the channel indicate the channel state to be $F$, then the two
virtual channel times associated with the sender and receiver views coincide
and are less than the two local virtual times of the sender and receiever
processes. The channel information is maintained in a \emph{local} map $\Xi$
associated with each process.

\paragraph*{Communication Model.} We focus on \emph{synchronous}
channel-based communication. The model supports \emph{choice}: the expression
$\recv{x_1}{\ell_1}{x_2}{\ell_2}$ can receive a message on either channel
$\ell_1$ or $\ell_2$. If both choices are offered, the evaluation of the
expression is permitted to choose which one to accept. Extending this model
to handle any finite number of choices is straightforward but complicates the
presentation of the semantics. The accompanying implementation allows a list
of choices.

\paragraph*{Processes.} A process computes forward and backwards sending and
receiving messages. To enable distributed backtracking, each process maintain
a virtual time $t$, a channel map $\Xi$, and a stack $\Gamma$ of
contexts. Each context includes a conventional continuation (a control point
and an environment), a value saved to resume asynchronous backtracks forced
by communicating neighbors, a time stamp, and a channel map describing the
state of the communication channels at the time of the checkpoint. A process
state is \emph{stable} if the process virtual time is greater than or equal
to the times of the channels in its context and channel map.

\paragraph*{Grammar.}

\[\begin{array}{lrcl}
(\textit{process names}) & n, \ldots \\
(\textit{channel names}) & \ell, \ldots \\
(\textit{time stamps}) & t, \ldots \\
\\
(\textit{channel direction}) & d &::=& F \alt B \\
(\textit{channel port}) & sr &::=& \textbf{s} \alt \textbf{r} \\
(\textit{channel maps}) & \Xi &=& \ell \mapsto (sr,t,d,n) \\
(\textit{context stacks}) & \Gamma &=& \bullet \alt \Gamma,(E,v,t,\Xi) \\
\\
(\textit{processes}) & p &::=& (\parc{p_1}{p_2}) \alt \proc{n}{\Gamma}{\Xi}{e}{t} \\
\\
(\textit{values}) & v &::=& () \alt \ell \alt x \alt \lambda x.e \\
(\textit{expressions}) & e &::=& () \alt \ell \alt x \alt \lambda x.e 
  \alt e_1e_2 \\
  &&\alt& \send{e_1}{e_2} \alt \recv{x_1}{e_1}{x_2}{e_2} \\
  &&\alt& \stable{e} \alt \stableu{e} \alt \backtrack{e} \alt \abacktrack \\
\\
(\textit{evaluation contexts}) & E &::=& \Box \alt E~e \alt v~E \alt 
  \send{E}{e} \alt \send{\ell}{E} \\
  &&\alt& \recv{x_1}{E}{x_2}{e_2} \alt \recv{x_1}{\ell_1}{x_2}{E} \\
  &&\alt& \stable{E} \alt \stableu{E} \alt \backtrack{E}
\end{array}\]

We use $e_1;e_2$ as syntactic sugar for $(\lambda \_.e_2)~e_1$ to indicate
sequencing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Semantics} 

Initially, every process starts with virtual time 0, a channel map
associating each channel that this process can use as a sender or receiver to
$(0,F,n)$ where $n$ is the process at the other end of the channel, an empty
stack of contexts, and an expression to evaluate, i.e., process $n_i$ with
code $e_i$ starts in the configuration
$\proc{n_i}{\bullet}{\Xi_i}{\Box[e_i]}{0}$ where $\Xi_1$ is the initial
channel map as explained above. The rules for evolving the collection of
processes are as follows:

\begin{itemize}
\item The first rule just applies a local evaluation rule to one of the
  running processes. The remaining processes, the local timestamp, the local
  channel map, and the local stack of contexts are all left untouched. (We
  only increase the timestamp for ``relevant'' rules which involve
  communication.)
\[\begin{array}{rcl}
  \parc{p}{\proc{n}{\Gamma}{\Xi}{E[(\lambda x.e)~v]}{t}} &\mapsto& 
  \parc{p}{\proc{n}{\Gamma}{\Xi}{E[e[v/x]]}{t}}
\end{array}\]

\item This next rule deals with the normal forward communication between two
  processes. 

says that if we have a channel $\ell$ with flag $F$ and two
  processes who wish to communicate using this channel, the synchronization
  happens as usual. After the communication, all three timestamps are updated
  to some number that is greater than or equal to their maximum:
\[\begin{array}{l}
  \parc{p}
  {\parc{\proc{n_1}{\Gamma_1}{\Xi_1}{E_1[\send{\ell}{v}]}{t_1}}
        {\proc{n_2}{\Gamma_2}{\Xi_2}{E_2[\recv{x}{\ell}{x'}{\ell'}]}{t_2}}}
  \mapsto \\
  \parc{p}{\parc{\proc{n_1}{\Gamma_1}{\Xi_1'}{E_1[()]}{t}}
    {\proc{n_2}{\Gamma_2}{\Xi_2'}{E_2[v]}{t}}}
\end{array}\]
The preconditions for this rule are: 
\begin{itemize}
\item the sender's local channel map associates $\ell$ with
  $(\textbf{s},t_s,F,n_2)$, i.e., the map correctly identifies $n_2$ as the
  receiving process, and records that the channel direction is $F$, and has
  some virtual time $t_s$;
\item the receiver's local channel map associates $\ell$ with
  $(\textbf{r},t_r,F,n_1)$, i.e., the map correctly identifies $n_1$ as the
  sending process, and records that the channel direction is $F$, and has
  some virtual time $t_r$; and
\item the sender's virtual time is greater than or equal to the channel's
  virtual time in the sender's map, i.e., $t_1 \geq t_s$, and similarly for
  the receiver's virtual time, i.e., $t_2 \geq t_r$.
\end{itemize}
If these conditions are satisfied, the communication happens, and the virtual
times for the sender, receiver, and the channel times in each local map are
all updated to some time $t$ greater than the maximum of
$\{t_1,t_2,t_s,t_r\}$. In other words, the sender's resulting local map
$\Xi_1'$ associates $\ell$ with $(\textbf{s},t,F,n_2)$, and the receiver's
resulting local map $\Xi_2'$ associates $\ell$ with
$(\textbf{r},t,F,n_1)$. In the rule, the receiver non-deterministically
``chose'' to communicate on channel $\ell$. If another process $n_1'$ was
ready to communicate on channel $\ell'$ (and the preconditions were satisfied
for that communication), the receiver could have synchronized wit $n_1'$
using the same rule.

\item The next two rules deal with stable regions. When a new stable region
  is encountered, the evaluation increments the timestamp and saves a new
  context, which is restored should the evaluation backtrack within the
  dynamic extent of the stable region:
\[\begin{array}{rcl}
  \parc{p}{\proc{n}{\Gamma}{\Xi}{E[(\stable{(\lambda x.e)})~v]}{t}} &\mapsto&
  \parc{p}{\proc{n}{\Gamma'}{\Xi}{E[\stableu{e[v/x]}]}{(t+1)}} 
\end{array}\]
where $\Gamma' = \Gamma,(E,v,(t+1),\Xi)$. When the body of a stable 
region terminates with a value, we simply pop the context:
\[\begin{array}{rcl}
  \parc{p}{\proc{n}{(\Gamma,(E,v',t',\Xi'))}{\Xi}{E[\stableu{v}]}{t}} 
  &\mapsto& 
  \parc{p}{\proc{n}{\Gamma}{\Xi}{E[v]}{t}} 
\end{array}\]

\item So far, none of the rules caused any virtual time to decrease. When a
  process $n$ backtracks, however, its virtual time is reinstated to a
  previously saved time. In addition, we recover the saved state of the
  channels updating the channels that need to backtrack to have a flag $B$. A
  channel needs to backtrack if it was used for communication since it was
  last saved, i.e., if its saved time is less than its current time. We then
  resume execution with the saved continuation:
\[\begin{array}{rcl}
  \parc{p}{\proc{n}{(\Gamma,(E',v',t',\Xi'))}{\Xi}{E[\backtrack{v}]}{t}} 
  &\mapsto& 
  \parc{p}{\proc{n}{\Gamma}{\overline{\Xi'}}{E'[v]}{t'}} \\
\\
  \parc{p}{\proc{n}{(\Gamma,(E',v',t',\Xi'))}{\Xi}{E[\abacktrack]}{t}} 
  &\mapsto& 
  \parc{p}{\proc{n}{\Gamma}{\overline{\Xi'}}{E'[v']}{t'}} 
\end{array}\]
where $\underline{\Xi'}$ denotes the channel map $\Xi$ with each entry that
needs to be backtrack updated to have direction $B$. An entry $\ell \mapsto
(sr,t,d,n)$ in $\Xi'$ needs to backtrack if its time component $t$ is less
than the corresponding time $t'$ in the current map entry $\Xi(\ell) =
(sr',t',d',n')$.

\item The next rule deals with the situation in which one of the
  processes has backtracked but its communication partner has not. In more
  detail, if a channel $\ell$ is such that one of its attached processes
  views it in the $F$ direction and the other attached process views it in
  the $B$ direction, the former needs to backtrack to bring the channel to a
  consistent state:
\[\begin{array}{rcl}
\parc{p}
  {\parc{\proc{n_1}{\Gamma_1}{\Xi_1}{e_1}{t_1}}
  {\proc{n_2}{\Gamma_2}{\Xi_2}{e_2}{t_2}}} &\mapsto& 
\parc{p}
  {\parc{\proc{n_1}{\Gamma_1}{\Xi_1}{e_1}{t_1}}
  {\proc{n_2}{\Gamma_2}{\Xi_2}{\abacktrack}{t_2}}} 
\end{array}\]

if $(\ell,(t_c,B,n_1,n_2)) \in \Xi_1$ and $t_c < t_1$. This condition
indicates that $n_2$ has backtracked to a time consistent with $t_c$ and
hence that $n_1$ is still in the (inconsistent) future and hence should do
the same. We achieve this by executing $\abacktrack$ which moves to the most
recent saved context and attempts to re-execute the communication.  If that
fails, this same rule applies and we backtrack again.  There is a symmetric
rule for receivers.

Eventually, the process backtracks to a time $t_1$ such that $t_c \geq t_1$,
at which we can revert the channel to the flag $F$:
\[\begin{array}{l}
  \Xi_1,
  \parc{p}{\proc{n_1}{\Gamma}{\Xi}{E[\send{\ell}{v}]}{t_1}} \mapsto \\
  \Xi_2,
  \parc{p}{\proc{n_1}{\Gamma}{\Xi}{E[\send{\ell}{v}]}{t_1}} 
\end{array}\]
if $(\ell,(t_c,B,n_1,n_2)) \in \Xi_1$ and $t_c \geq t_1$ and channel $\ell$'s
information in $\Xi_2$ is updated to $t_c,F,n_1,n_2)$.

Fold this rule in the communication rule: add side conditions to
communication rule if channels are B and channel time is greater than of
equal to process time; in that case we do communication and update channels
to have flag F.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
